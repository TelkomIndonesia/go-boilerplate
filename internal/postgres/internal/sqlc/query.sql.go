// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"errors"
	"iter"

	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/telkomindonesia/go-boilerplate/internal/postgres/internal/types"
)

type resultModifier[T any] struct {
	preScanFunc  func(*T)
	postScanFunc func(*T) (ok bool, err error)
}

func PreModifer[T any](preScanFunc func(result *T)) resultModifier[T] {
	return resultModifier[T]{
		preScanFunc:  preScanFunc,
		postScanFunc: func(t *T) (ok bool, err error) { return true, nil },
	}
}

func PostModifier[T any](postScanFunc func(result *T) (ok bool, err error)) resultModifier[T] {
	return resultModifier[T]{
		preScanFunc:  func(t *T) {},
		postScanFunc: postScanFunc,
	}
}

func PrePostModifier[T any](preScanFunc func(result *T), postScanFunc func(result *T) (ok bool, err error)) resultModifier[T] {
	return resultModifier[T]{
		preScanFunc:  preScanFunc,
		postScanFunc: postScanFunc,
	}
}

type SeqWErr[V any] struct {
	seq iter.Seq[V]
	err error
}

func (s *SeqWErr[V]) Seq() iter.Seq[V] {
	if s == nil {
		return func(yield func(V) bool) {}
	}
	return s.seq
}

func (s *SeqWErr[V]) Err() error {
	if s == nil {
		return nil
	}
	return s.err
}

const fetchProfile = `-- name: FetchProfile :one
SELECT 
    nin, name, phone, email, dob 
FROM 
    profile 
WHERE 
    id = $1 AND tenant_id = $2
`

type FetchProfileParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

type FetchProfileRow struct {
	Nin   types.AEADString
	Name  types.AEADString
	Phone types.AEADString
	Email types.AEADString
	Dob   types.AEADTime
}

// FetchProfile
//
//	SELECT
//	    nin, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	    id = $1 AND tenant_id = $2
func (q *Queries) FetchProfile(ctx context.Context, arg FetchProfileParams, mods ...resultModifier[FetchProfileRow]) (FetchProfileRow, error) {
	row := q.db.QueryRowContext(ctx, fetchProfile, arg.ID, arg.TenantID)
	var i FetchProfileRow

	for _, mod := range mods {
		mod.preScanFunc(&i)
	}

	err := row.Scan(
		&i.Nin,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Dob,
	)

	for _, mod := range mods {
		_, err := mod.postScanFunc(&i)
		if err != nil {
			return i, err
		}
	}

	return i, err
}

const findProfilesByName = `-- name: FindProfilesByName :many
SELECT 
    id, tenant_id, nin, name, phone, email, dob 
FROM 
    profile 
WHERE 
    tenant_id = $1 and name_bidx = ANY($2)
`

type FindProfilesByNameParams struct {
	TenantID uuid.UUID
	NameBidx types.BIDXString
}

type FindProfilesByNameRow struct {
	ID       uuid.UUID
	TenantID uuid.UUID
	Nin      types.AEADString
	Name     types.AEADString
	Phone    types.AEADString
	Email    types.AEADString
	Dob      types.AEADTime
}

// FindProfilesByName returns a single-use iterator.
// FindProfilesByName
//
//	SELECT
//	    id, tenant_id, nin, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	    tenant_id = $1 and name_bidx = ANY($2)
func (q *Queries) FindProfilesByName(ctx context.Context, arg FindProfilesByNameParams, mods ...resultModifier[FindProfilesByNameRow]) (seq *SeqWErr[FindProfilesByNameRow], err error) {
	rows, err := q.db.QueryContext(ctx, findProfilesByName, arg.TenantID, arg.NameBidx)
	if err != nil {
		return nil, err
	}

	seq = &SeqWErr[FindProfilesByNameRow]{}
	seq.seq = func(yield func(FindProfilesByNameRow) bool) {
		defer func() {
			if cerr := rows.Close(); cerr != nil {
				seq.err = errors.Join(seq.err, cerr)
			}
			if serr := rows.Err(); serr != nil {
				seq.err = errors.Join(seq.err, serr)
			}
		}()

		for rows.Next() {
			var i FindProfilesByNameRow

			for _, mod := range mods {
				mod.preScanFunc(&i)
			}

			if err := rows.Scan(
				&i.ID,
				&i.TenantID,
				&i.Nin,
				&i.Name,
				&i.Phone,
				&i.Email,
				&i.Dob,
			); err != nil {
				seq.err = err
				return
			}

			added := true
			for _, mod := range mods {
				ok, err := mod.postScanFunc(&i)
				if err != nil {
					seq.err = err
					return
				}
				added = added && ok
			}
			if !added {
				continue
			}

			if !yield(i) {
				return
			}
		}
		return
	}

	return
}

const findTextHeap = `-- name: FindTextHeap :many
SELECT 
    content 
FROM 
    text_heap 
WHERE 
    tenant_id = $1 AND type = $2 
    AND content LIKE $3 || '%'
`

type FindTextHeapParams struct {
	TenantID uuid.UUID
	Type     string
	Content  sql.NullString
}

// FindTextHeap returns a single-use iterator.
// FindTextHeap
//
//	SELECT
//	    content
//	FROM
//	    text_heap
//	WHERE
//	    tenant_id = $1 AND type = $2
//	    AND content LIKE $3 || '%'
func (q *Queries) FindTextHeap(ctx context.Context, arg FindTextHeapParams, mods ...resultModifier[string]) (seq *SeqWErr[string], err error) {
	rows, err := q.db.QueryContext(ctx, findTextHeap, arg.TenantID, arg.Type, arg.Content)
	if err != nil {
		return nil, err
	}

	seq = &SeqWErr[string]{}
	seq.seq = func(yield func(string) bool) {
		defer func() {
			if cerr := rows.Close(); cerr != nil {
				seq.err = errors.Join(seq.err, cerr)
			}
			if serr := rows.Err(); serr != nil {
				seq.err = errors.Join(seq.err, serr)
			}
		}()

		for rows.Next() {
			var content string

			for _, mod := range mods {
				mod.preScanFunc(&content)
			}

			if err := rows.Scan(&content); err != nil {
				seq.err = err
				return
			}

			added := true
			for _, mod := range mods {
				ok, err := mod.postScanFunc(&content)
				if err != nil {
					seq.err = err
					return
				}
				added = added && ok
			}
			if !added {
				continue
			}

			if !yield(content) {
				return
			}
		}
		return
	}

	return
}

const storeProfile = `-- name: StoreProfile :exec
INSERT INTO profile
    (id, tenant_id, nin, nin_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (id) 
    DO UPDATE SET updated_at = NOW()
`

type StoreProfileParams struct {
	ID        uuid.UUID
	TenantID  uuid.UUID
	Nin       types.AEADString
	NinBidx   types.BIDXString
	Name      types.AEADString
	NameBidx  types.BIDXString
	Phone     types.AEADString
	PhoneBidx types.BIDXString
	Email     types.AEADString
	EmailBidx types.BIDXString
	Dob       types.AEADTime
}

// StoreProfile
//
//	INSERT INTO profile
//	    (id, tenant_id, nin, nin_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
//	VALUES
//	    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
//	ON CONFLICT (id)
//	    DO UPDATE SET updated_at = NOW()
func (q *Queries) StoreProfile(ctx context.Context, arg StoreProfileParams) error {
	_, err := q.db.ExecContext(ctx, storeProfile,
		arg.ID,
		arg.TenantID,
		arg.Nin,
		arg.NinBidx,
		arg.Name,
		arg.NameBidx,
		arg.Phone,
		arg.PhoneBidx,
		arg.Email,
		arg.EmailBidx,
		arg.Dob,
	)
	return err
}

const storeTextHeap = `-- name: StoreTextHeap :exec


INSERT INTO text_heap 
	(tenant_id, type, content)
VALUES
	($1, $2, $3)
ON CONFLICT (tenant_id, type, content) 
    DO NOTHING
`

type StoreTextHeapParams struct {
	TenantID uuid.UUID
	Type     string
	Content  string
}

// https://docs.sqlc.dev/en/latest/howto/named_parameters.html#naming-parameters
//
//	INSERT INTO text_heap
//		(tenant_id, type, content)
//	VALUES
//		($1, $2, $3)
//	ON CONFLICT (tenant_id, type, content)
//	    DO NOTHING
func (q *Queries) StoreTextHeap(ctx context.Context, arg StoreTextHeapParams) error {
	_, err := q.db.ExecContext(ctx, storeTextHeap, arg.TenantID, arg.Type, arg.Content)
	return err
}
