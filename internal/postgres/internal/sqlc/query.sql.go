// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/telkomindonesia/go-boilerplate/internal/postgres/internal/sqlc/types"
)

const fetchProfile = `-- name: FetchProfile :one
SELECT 
    nin, name, phone, email, dob 
FROM 
    profile 
WHERE 
    id = $1 AND tenant_id = $2
`

type FetchProfileParams struct {
	ID       uuid.UUID
	TenantID uuid.UUID
}

type FetchProfileRow struct {
	Nin   types.AEADString
	Name  types.AEADString
	Phone types.AEADString
	Email types.AEADString
	Dob   types.AEADTime
}

// FetchProfile
//
//	SELECT
//	    nin, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	    id = $1 AND tenant_id = $2
func (q *Queries) FetchProfile(ctx context.Context, arg FetchProfileParams, iOptionalInitFunc func(*FetchProfileRow)) (FetchProfileRow, error) {
	row := q.db.QueryRowContext(ctx, fetchProfile, arg.ID, arg.TenantID)
	var i FetchProfileRow
	if iOptionalInitFunc != nil {
		iOptionalInitFunc(&i)
	}

	err := row.Scan(
		&i.Nin,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Dob,
	)
	return i, err
}

const findProfilesByName = `-- name: FindProfilesByName :many
SELECT 
    id, tenant_id, nin, name, phone, email, dob 
FROM 
    profile 
WHERE 
    tenant_id = $1 and name_bidx = ANY($2)
`

type FindProfilesByNameParams struct {
	TenantID uuid.UUID
	NameBidx types.BIDXString
}

type FindProfilesByNameRow struct {
	ID       uuid.UUID
	TenantID uuid.UUID
	Nin      types.AEADString
	Name     types.AEADString
	Phone    types.AEADString
	Email    types.AEADString
	Dob      types.AEADTime
}

// FindProfilesByName
//
//	SELECT
//	    id, tenant_id, nin, name, phone, email, dob
//	FROM
//	    profile
//	WHERE
//	    tenant_id = $1 and name_bidx = ANY($2)
func (q *Queries) FindProfilesByName(ctx context.Context, arg FindProfilesByNameParams, iOptionalInitFunc func(*FindProfilesByNameRow), iOptionalFilterFunc func(FindProfilesByNameRow) (bool, error)) ([]FindProfilesByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, findProfilesByName, arg.TenantID, arg.NameBidx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindProfilesByNameRow
	for rows.Next() {
		var i FindProfilesByNameRow
		if iOptionalInitFunc != nil {
			iOptionalInitFunc(&i)
		}

		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Nin,
			&i.Name,
			&i.Phone,
			&i.Email,
			&i.Dob,
		); err != nil {
			return nil, err
		}

		if iOptionalFilterFunc != nil {
			add, err := iOptionalFilterFunc(i)
			if err != nil {
				return nil, err
			}
			if !add {
				continue
			}
		}

		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTextHeap = `-- name: FindTextHeap :many
SELECT 
    content 
FROM 
    text_heap 
WHERE 
    tenant_id = $1 AND type = $2 
    AND content LIKE $3 || '%'
`

type FindTextHeapParams struct {
	TenantID uuid.UUID
	Type     string
	Content  sql.NullString
}

// FindTextHeap
//
//	SELECT
//	    content
//	FROM
//	    text_heap
//	WHERE
//	    tenant_id = $1 AND type = $2
//	    AND content LIKE $3 || '%'
func (q *Queries) FindTextHeap(ctx context.Context, arg FindTextHeapParams, contentOptionalInitFunc func(*string), contentOptionalFilterFunc func(string) (bool, error)) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, findTextHeap, arg.TenantID, arg.Type, arg.Content)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var content string
		if contentOptionalInitFunc != nil {
			contentOptionalInitFunc(&content)
		}

		if err := rows.Scan(&content); err != nil {
			return nil, err
		}

		if contentOptionalFilterFunc != nil {
			add, err := contentOptionalFilterFunc(content)
			if err != nil {
				return nil, err
			}
			if !add {
				continue
			}
		}

		items = append(items, content)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeProfile = `-- name: StoreProfile :exec
INSERT INTO profile
    (id, tenant_id, nin, nin_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (id) 
    DO UPDATE SET updated_at = NOW()
`

type StoreProfileParams struct {
	ID        uuid.UUID
	TenantID  uuid.UUID
	Nin       types.AEADString
	NinBidx   types.BIDXString
	Name      types.AEADString
	NameBidx  types.BIDXString
	Phone     types.AEADString
	PhoneBidx types.BIDXString
	Email     types.AEADString
	EmailBidx types.BIDXString
	Dob       types.AEADTime
}

// StoreProfile
//
//	INSERT INTO profile
//	    (id, tenant_id, nin, nin_bidx, name, name_bidx, phone, phone_bidx, email, email_bidx, dob)
//	VALUES
//	    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
//	ON CONFLICT (id)
//	    DO UPDATE SET updated_at = NOW()
func (q *Queries) StoreProfile(ctx context.Context, arg StoreProfileParams) error {
	_, err := q.db.ExecContext(ctx, storeProfile,
		arg.ID,
		arg.TenantID,
		arg.Nin,
		arg.NinBidx,
		arg.Name,
		arg.NameBidx,
		arg.Phone,
		arg.PhoneBidx,
		arg.Email,
		arg.EmailBidx,
		arg.Dob,
	)
	return err
}

const storeTextHeap = `-- name: StoreTextHeap :exec


INSERT INTO text_heap 
	(tenant_id, type, content)
VALUES
	($1, $2, $3)
ON CONFLICT (tenant_id, type, content) 
    DO NOTHING
`

type StoreTextHeapParams struct {
	TenantID uuid.UUID
	Type     string
	Content  string
}

// https://docs.sqlc.dev/en/latest/howto/named_parameters.html#naming-parameters
//
//	INSERT INTO text_heap
//		(tenant_id, type, content)
//	VALUES
//		($1, $2, $3)
//	ON CONFLICT (tenant_id, type, content)
//	    DO NOTHING
func (q *Queries) StoreTextHeap(ctx context.Context, arg StoreTextHeapParams) error {
	_, err := q.db.ExecContext(ctx, storeTextHeap, arg.TenantID, arg.Type, arg.Content)
	return err
}
